# -*- in-config-file: t -*-

reminder to self: g<tab> unfolds headings, for when you open this file and forget the keybinding.


* Wth?

I'm now running this emacs config on my mac!  I've escaped spacemacs!  Even though 
it's not done yet, it's functional enough that I can use it, and I got sick of worrying about what kinds 
of things would have to be changed after moving machines.

doing the literate org config, so this readme file is also my config file!  (Well, most of it.  I 
defined a little bit of stuff that applies to this file itself, like a snippet to get elisp code blocks 
that I didn't know how to escape, in init.el.)  So that's cool.


** Conventions

   - I use the tag *dev* for headlines that contain code that might go away when I'm happy with this config, like the snippet I bound to @ below.

   - I use the tag *key* for headlines that contain code with a keybinding in it.  This is for ease of later documentation.
     - At some point I want to create a personal usage manual.

   - I use the tag *fragile* for headlines containing code with non-obvious or even downright mysterious failure potential, where I made it work with pure guesswork.

   - As much as possible, I try to keep keybindings together rather than with their associated packages.  This might be a mistake?

* Package management

[[https://github.com/raxod502/straight.el][Straight]] appears to be an /actual package manager/ unlike stuff like use-package.  I can get a lockfile with commit hashes for every package I use with ~(straight-freeze-versions)~ . 

Given that emacs packages seem to just /love/ generating side effects, this seems like a thing that is absolutely mandatory. I've already had one nasty package conflict scare.

#+BEGIN_SRC emacs-lisp

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+END_SRC



* Browsing and Finding Things 

** Files and such  :fragile: 

Note *IMPORTANT*: this needs to be invoked right after use-package.  When it's further down in the init, it seems to be clobbered 
by some other package, and starts generating weird rgb errors.  I think it has something to do with doom-theme, but 
I also just tried a bare init and then loaded doom theme and this and it's ok somehow.  So somehow 
there might be a three-way conflict between doom-theme this and some other package?  Fuck if I know.  

[[https://github.com/abo-abo/swiper/issues/2748][unholy details here]]

update: this may be fixed; I swapped in a new version of the swiper library and moved the installation of counsel 
down to the bottom of the file, and it worked just fine. 

Spacemacs uses helm, but lots of people who start with helm seem to love Ivy

#+BEGIN_SRC emacs-lisp
(straight-use-package 'counsel)
(ivy-mode 1)
#+END_SRC

** Commands

Which-key is apparently The Thing 

#+BEGIN_SRC emacs-lisp
(straight-use-package 'which-key)
(require 'which-key)
(which-key-mode)
#+END_SRC


* Evilify everything because emacs keybindings are horrible

** Base evil 

#+BEGIN_SRC emacs-lisp

(straight-use-package 'evil)
(setq evil-want-keybinding nil)  ;; this is apparently required for evil-collection keybindings.
(require 'evil)
(evil-mode)

#+END_SRC

** Add more evil bindings
Let's get as much evilified as humanly possible just to start, eh?

#+BEGIN_SRC emacs-lisp

(straight-use-package 'evil-commentary)
(require 'evil-commentary)
(evil-commentary-mode)

(straight-use-package 'evil-collection)

(straight-use-package 'evil-org)
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional calendar))
(require 'evil-org-agenda)
(evil-org-agenda-set-keys)

#+END_SRC


* Visual 

** Theme


Setup

#+BEGIN_SRC emacs-lisp
(straight-use-package 'doom-themes) 
#+END_SRC

Convenience functions

#+BEGIN_SRC emacs-lisp

(defvar dark-theme 'doom-sourcerer)
(defvar light-theme 'doom-opera-light)

(defun disable-all-themes ()
  "disable all active themes."
  (dolist (i custom-enabled-themes)
    (disable-theme i)))

(defun dark-mode ()
(interactive)
(disable-all-themes)
(load-theme dark-theme t))


(defun light-mode ()
(interactive)
(disable-all-themes)
(load-theme light-theme t))


#+END_SRC


Dark mode for programming 

I'm not going to use prog-mode-hook on this because it seems to fire it off on org?  but I want org to be light...

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'dark-mode)
#+END_SRC

Light mode for writing

gonna fire this up for markdown mode too.  Maybe it would make sense to define a writing mode hook encompassing org mode and markdown mode?

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'light-mode)
#+END_SRC

This doesn't seem to work perfectly: if I start in an org buffer then open the python buffer, the hook fires and I go dark.  but then if I close the python buffer even though the 
org mode buffer is back on the screen it doesn't go light again.  It does go light if I close the org buffer and reopen it though.  Hmm.  For now I think I'll just toss in a quick keybinding to fix it. 

Start out in light mode

#+BEGIN_SRC emacs-lisp
(light-mode)
#+END_SRC


** Font

#+BEGIN_SRC emacs-lisp
(set-frame-font "Inconsolata Bold 16" nil t)
#+END_SRC

** GUI tweaks

Get rid of menubar, toolbar, scrollbar


#+BEGIN_SRC emacs-lisp

(menu-bar-mode -1)
(tool-bar-mode -1)
(toggle-scroll-bar -1)
#+END_SRC

Start full-sized

#+BEGIN_SRC emacs-lisp
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+END_SRC

** Rainbow parens

Can't even begin to edit elisp without this, I want it in this mode noooow.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'rainbow-delimiters)
(add-hook 'org-mode-hook #'rainbow-delimiters-mode)
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+END_SRC


** Modeline


#+BEGIN_SRC emacs-lisp

(straight-use-package 'telephone-line)

(setq telephone-line-lhs
      '((evil   . (telephone-line-airline-position-segment
                   telephone-line-evil-tag-segment
                   telephone-line-vc-segment
                   telephone-line-process-segment
                   telephone-line-buffer-segment
                   telephone-line-buffer-modified-segment))
))
(setq telephone-line-rhs
      '((evil    . (telephone-line-major-mode-segment))
))

(telephone-line-mode 1)

#+END_SRC



* Keybindings

** Bust out General

I think I pretty much just only want these keybindings in normal mode for now.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'general)

(defconst leader "SPC")
(defconst mode-leader ",")
(general-create-definer leader-binding
  :prefix leader
  :states 'normal
  :keymaps 'override) 

(general-create-definer mode-binding
  :prefix mode-leader
  :states 'normal
  :keymaps 'override)

#+END_SRC

** Global leader keybindings 


GLOBAL KEYBINDINGS FROM LEADER KEY 

| command | function               |
| f f     | find file              |
| f s     | save file              |
| f n     | save to new name       |
| w /     | new window to right    |
| w -     | new window below       |
| w d     | delete current window  |
| w x     | delete other windows   |
| w c     | cycle to next window   |
| b d     | kill buffer            |
| b b     | buffer menu            |
| e e     | eval sexp before point |
|         |                        |


*** Files   :key:

tryna swipe the bindings I use most often in spacemacs

#+BEGIN_SRC emacs-lisp

(leader-binding
"f" '(:ignore t :which-key "Files")
"ff" 'counsel-find-file
"fs" 'save-buffer
"fn" 'write-file)

#+END_SRC

*** Buffers    :key:


#+BEGIN_SRC emacs-lisp

(leader-binding
"b" '(:ignore t :which-key "Buffers")
"bd" 'kill-this-buffer
"bb" 'ivy-switch-buffer)

#+END_SRC

*** Windows   :key: 


#+BEGIN_SRC emacs-lisp

(leader-binding
"w" '(:ignore t :which-key "Windows")
"w/" 'split-window-right
"w-" 'split-window-below
"wd" 'delete-window
"wx" 'delete-other-windows
"wc" 'other-window)

#+END_SRC

*** Colors :key:

#+BEGIN_SRC emacs-lisp
;(leader-binding
;"c" '(:ignore t :which-key "Colors")
;"cl" 'light-mode
;"ed" 'dark-mode)
#+END_SRC

*** Elisp :key:

I want keybindings to quickly evaluate some elisp so that I don't have to remember the command to try a tweak in this config/later.


#+BEGIN_SRC emacs-lisp
(leader-binding
"e" '(:ignore t :which-key "Elisp")
"ee" 'eval-last-sexp)
#+END_SRC

** Mode-specific leader keybindings

*** Org mode

**** Ergonomic header and todo cycling                                  :key:

ORG MODE, NORMAL: 

| command | function     |
|---------+--------------|
| , t     | cycle todo   |
| , f     | cycle header |
|         |              |


#+BEGIN_SRC emacs-lisp

(mode-binding 
:keymaps 'org-mode-map
"t" 'org-todo
"f" 'org-cycle )

#+END_SRC



* Languages 

** Completion, generally

#+BEGIN_SRC emacs-lisp
(straight-use-package 'company)
(add-hook 'prog-mode-hook 'company-mode)
(straight-use-package 'company-quickhelp)
(add-hook 'prog-mode-hook 'company-quickhelp-mode)
#+END_SRC

** Line numbers, generally

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'linum-mode)
(setq linum-format "%4d \u2502 ")
#+END_SRC

** Python  :fragile:

This is marked fragile because it will depend on local python config. On the PI, I used an alias to get python3 to be python, 
and then I pip-3 installed jedi, black, autopep8, and yapf.  On the real machine, there'll have to be some kind of virtualenv thing happening. 


*** Anaconda

#+BEGIN_SRC emacs-lisp
(straight-use-package 'anaconda-mode)
(eval-after-load "company"
 '(add-to-list 'company-backends 'company-anaconda))
(add-hook 'python-mode-hook 'anaconda-mode)
#+END_SRC

*** PYTHON TODO 

- make sure this works on real machine, haven't checked after moving to prod.

- add [[https://github.com/pythonic-emacs/blacken][blacken]]

- add and set up [[https://www.flycheck.org/en/latest/user/installation.html][flycheck]] for syntax checking (probably for other languages too)

- some kind of venv thing like [[https://github.com/marcwebbie/auto-virtualenv][auto-virtualenv]] --- or maybe [[https://github.com/pwalsh/pipenv.el][integrate with pipenv?]] [[https://github.com/pythonic-emacs/pyenv-mode][pyenv mode?]] [[https://github.com/Rokutann/npy.el][npy.el]]?  This may have to wait till real machine.

- keybindings for a shell?  maybe also after.  (and for sending commands to shell etc.)

- test runner support?  

* Development (of emacs config) conveniences   :dev: 


** Keybinding to make delimiter for elisp blocks with @         

This is slightly black-magic-ey.  add-lisp-delimiters is defined in init.el. 
That function looks for a variable called in-config-file, and, if it's set 
(as it is on the very first line of this file... and apparently it has to be the very 
first line, the second line won't do), then it pastes in the BEGIN_SRC stuff. So I bind it to ampersand, 
because I don't *think* anything else uses @ ...?



#+BEGIN_SRC emacs-lisp

(add-hook 'org-mode-hook 
  (lambda () 
    (evil-global-set-key 'normal (kbd "@") 'add-lisp-delimiters)))

#+END_SRC








* TODO enhancements to make
** Fancier modeline with mode and git enhancements
   - I'm happy with [[https://github.com/dbordak/telephone-line/][telephone-line]] for now, except I'd like to be able to have three color chunks, one reflecting mode, 1 reflecting file save status, and 1 reflecting git status.
** minor keybinding tweaks
     - [[https://emacs.stackexchange.com/a/13770/12604][swipe this]] and map it to escape to allow me to bail from any command in normal mode
     - bind the arrow keys to paging in which-keys (so sue me, I like arrow keys)
** editing tweaks
   - word wraps --- I could just set (global-visual-line-mode 1) but I wonder if I want it mode specific?
** some kind of non-utf-8 utility
   actually, I really want something that will highlight (a) non utf-8 characters, and (b) characters that look like normal ascii characters but aren't.
   - this might be ok just for markdown mode. the point is for copy-paste quotes that introduce shit characters that blow up latex
** swipe-scrolling on the touchpad like with vim
** TODO Language support
   this is the list of languages that I must have functioning before I'm even going to consider moving off 
   spacemacs.  Not the nice-to-have languages.
   only languages with actual projects that I might want to edit in the near future (so no haskell, go, etc.)
   and leaving off languages with perfectly good alternative editors (swift, r)
*** TODO Markdown
Not technically mandatory since I have lots of alternative editors, but since part of the point of this project
is wanting to be able to use emacs for markdown and I hate spacemacs markdown layer, let's do it.
**** TODO spell check
*** TODO Javascript
*** TODO HTML
*** TODO Vue.js
*** TODO Clojure
*** TODO shell scripts
*** TODO makefiles
*** TODO JSON
*** TODO YAML
** TODO better undo-redo 
** TODO window management
      - some kind of clone of spacemacs golden ratio mode

** TODO some kind of keybinding to bail out of partially typed commands.
* inspo

[[https://sam217pa.github.io/2016/09/02/how-to-build-your-own-spacemacs/][this person]] [[https://sam217pa.github.io/2016/08/30/how-to-make-your-own-spacemacs/][also]].
[[https://jamiecollinson.com/blog/my-emacs-config/#][this setup]]
